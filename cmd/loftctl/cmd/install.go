package cmd

import (
	"context"
	"crypto/tls"
	"fmt"
	"github.com/loft-sh/loftctl/cmd/loftctl/flags"
	"github.com/loft-sh/loftctl/pkg/client"
	"github.com/loft-sh/loftctl/pkg/log"
	"github.com/loft-sh/loftctl/pkg/survey"
	"github.com/spf13/cobra"
	corev1 "k8s.io/api/core/v1"
	kerrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/wait"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd"
	"net"
	"net/http"
	"net/url"
	"os/exec"
	"strings"
	"time"
)

// InstallCmd holds the cmd flags
type InstallCmd struct {
	*flags.GlobalFlags

	LocalPort        string
	SmartKubeContext bool
	Namespace        string
	Password         string

	Log log.Logger
}

// NewInstallCmd creates a new command
func NewInstallCmd(globalFlags *flags.GlobalFlags) *cobra.Command {
	cmd := &InstallCmd{
		GlobalFlags: globalFlags,
		Log:         log.GetInstance(),
	}

	loginCmd := &cobra.Command{
		Use:   "install",
		Short: "Install loft into a kubernetes cluster",
		Long: `
#######################################################
##################### loft install ####################
#######################################################
Installs loft into a kubernetes cluster. Please make
sure you meet the following requirements before running
loft install:

1. Have a kube context to a running kubernetes instance
2. Have helm v3 installed
3. Have kubectl installed

#######################################################
	`,
		Args: cobra.MaximumNArgs(1),
		RunE: func(cobraCmd *cobra.Command, args []string) error {
			return cmd.Run(cobraCmd, args)
		},
	}

	loginCmd.Flags().BoolVar(&cmd.SmartKubeContext, "smart-kube-context", true, "If enabled will save the kube context after installation and use it for the next time if the current context is generated by loft")
	loginCmd.Flags().StringVar(&cmd.Namespace, "namespace", "loft", "The namespace to install loft to")
	loginCmd.Flags().StringVar(&cmd.LocalPort, "local-port", "9898", "The local port to bind to if using port-forwarding")
	loginCmd.Flags().StringVar(&cmd.Password, "password", "", "The password to use for the admin account. (If empty this will be the namespace UID)")
	return loginCmd
}

// RunLogin executes the functionality "loft login"
func (cmd *InstallCmd) Run(cobraCmd *cobra.Command, args []string) error {
	loader, err := client.NewClientFromPath(cmd.Config)
	if err != nil {
		return err
	}
	loftConfig := loader.Config()

	// first load the kube config
	kubeClientConfig := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(clientcmd.NewDefaultClientConfigLoadingRules(), &clientcmd.ConfigOverrides{})

	// load the raw config
	kubeConfig, err := kubeClientConfig.RawConfig()
	if err != nil {
		return fmt.Errorf("There is an error loading your current kube config (%v), please make sure you have access to a kubernetes cluster and the command `kubectl get namespaces` is working.", err)
	}

	// we switch the context to the install config
	contextToLoad := kubeConfig.CurrentContext
	if cmd.SmartKubeContext && loftConfig.LastInstallContext != "" && loftConfig.LastInstallContext != contextToLoad && strings.HasPrefix(contextToLoad, "loft-") {
		contextToLoad = loftConfig.LastInstallContext
	}

	loftConfig.LastInstallContext = contextToLoad
	_ = loader.Save()

	// kube client config
	kubeClientConfig = clientcmd.NewNonInteractiveClientConfig(kubeConfig, contextToLoad, &clientcmd.ConfigOverrides{}, clientcmd.NewDefaultClientConfigLoadingRules())

	// test for helm and kubectl
	_, err = exec.Command("helm", "version").CombinedOutput()
	if err != nil {
		return fmt.Errorf("Seems like helm is not installed. Helm is required for the installation of loft. Please visit https://helm.sh/docs/intro/install/ for install instructions.")
	}
	_, err = exec.Command("kubectl", "version").CombinedOutput()
	if err != nil {
		return fmt.Errorf("Seems like kubectl is not installed. Kubectl is required for the installation of loft. Please visit https://kubernetes.io/docs/tasks/tools/install-kubectl/ for install instructions.")
	}

	restConfig, err := kubeClientConfig.ClientConfig()
	if err != nil {
		return fmt.Errorf("There is an error loading your current kube config (%v), please make sure you have access to a kubernetes cluster and the command `kubectl get namespaces` is working.", err)
	}
	kubeClient, err := kubernetes.NewForConfig(restConfig)
	if err != nil {
		return fmt.Errorf("There is an error loading your current kube config (%v), please make sure you have access to a kubernetes cluster and the command `kubectl get namespaces` is working.", err)
	}

	// Is already installed?
	isInstalled, err := cmd.isLoftAlreadyInstalled(kubeClient, contextToLoad)
	if err != nil {
		return err
	} else if isInstalled {
		return nil
	}

	cmd.Log.WriteString("\n")
	cmd.Log.Info("Welcome to the loft installation.")
	cmd.Log.Info("This installer will guide you through the installation.")
	cmd.Log.Info("If you prefer installing loft via helm yourself, visit https://loft.sh/docs/getting-started/setup")
	cmd.Log.Info("Thanks for trying out loft!")

	installLocally := cmd.isLocalCluster(restConfig.Host)
	remoteHost := ""

	if installLocally == false {
		const (
			YesOption = "Yes"
			NoOption  = "No, my cluster is running locally (docker desktop, minikube, kind etc.)"
		)

		answer, err := cmd.Log.Question(&survey.QuestionOptions{
			Question:     "Seems like your cluster is running remotely (GKE, AKS, EKS, private cloud etc.), is this correct?",
			DefaultValue: YesOption,
			Options: []string{
				YesOption,
				NoOption,
			},
		})
		if err != nil {
			return err
		}

		if answer == YesOption {
			remoteHost, err = cmd.askForHost()
			if err != nil {
				return err
			} else if remoteHost == "" {
				installLocally = true
			}
		} else {
			installLocally = true
		}
	} else {
		const (
			YesOption = "Yes"
			NoOption  = "No, I want to install loft with an external reachable url"
		)

		answer, err := cmd.Log.Question(&survey.QuestionOptions{
			Question:     "Seems like your cluster is running locally (docker desktop, minikube, kind etc.), is this correct?",
			DefaultValue: YesOption,
			Options: []string{
				YesOption,
				NoOption,
			},
		})
		if err != nil {
			return err
		}

		if answer == NoOption {
			installLocally = false

			remoteHost, err = cmd.askForHost()
			if err != nil {
				return err
			} else if remoteHost == "" {
				installLocally = true
			}
		}
	}

	if installLocally || remoteHost == "" {
		return cmd.installLocal(kubeClient, contextToLoad)
	}

	return cmd.installRemote(kubeClient, contextToLoad, remoteHost)
}

func (cmd *InstallCmd) isLoftAlreadyInstalled(kubeClient kubernetes.Interface, kubeContext string) (bool, error) {
	_, err := kubeClient.AppsV1().Deployments(cmd.Namespace).Get(context.TODO(), "loft", metav1.GetOptions{})
	if err != nil {
		if kerrors.IsNotFound(err) == true {
			return false, nil
		}

		return false, fmt.Errorf("error accessing kubernetes cluster: %v", err)
	}

	cmd.Log.Info("Found an existing loft installation")

	// get default password
	password, err := cmd.getDefaultPassword(kubeClient)
	if err != nil {
		return false, err
	}

	// check if local or remote installation
	_, err = kubeClient.NetworkingV1beta1().Ingresses(cmd.Namespace).Get(context.TODO(), "loft-ingress", metav1.GetOptions{})
	isLocal := kerrors.IsNotFound(err)
	if isLocal {
		err := cmd.startPortforwarding(kubeContext)
		if err != nil {
			return false, err
		}

		cmd.successLocal(password)
		return true, nil
	} else {
		// get login link
		cmd.Log.StartWait("Checking loft status...")
		host, err := cmd.getHost(kubeClient)
		cmd.Log.StopWait()
		if err != nil {
			return false, err
		}

		return true, cmd.successRemote(host, password)
	}

	return true, nil
}

func (cmd *InstallCmd) askForHost() (string, error) {
	for true {
		answer, err := cmd.Log.Question(&survey.QuestionOptions{
			Question: "Valid host for loft to be installed (e.g. loft.my-domain.com OR leave empty to use port-forwarding instead): \n",
		})
		if err != nil {
			return "", err
		} else if answer == "" {
			return "", nil
		}

		u, err := url.Parse("https://" + answer)
		if err != nil || u.Path != "" || u.Port() != "" {
			cmd.Log.Warnf("Please enter a valid host (without https://), without path and port, e.g. loft.my-domain.com")
			continue
		}

		return answer, nil
	}

	return "", fmt.Errorf("unreachable")
}

func init() {
	for _, cidr := range []string{
		"127.0.0.0/8",    // IPv4 loopback
		"10.0.0.0/8",     // RFC1918
		"172.16.0.0/12",  // RFC1918
		"192.168.0.0/16", // RFC1918
		"::1/128",        // IPv6 loopback
		"fe80::/10",      // IPv6 link-local
		"fc00::/7",       // IPv6 unique local addr
	} {
		_, block, _ := net.ParseCIDR(cidr)
		privateIPBlocks = append(privateIPBlocks, block)
	}
}

func (cmd *InstallCmd) isLocalCluster(host string) bool {
	url, err := url.Parse(host)
	if err != nil {
		cmd.Log.Warnf("Couldn't parse kube context host url: %v", err)
		return false
	}

	hostname := url.Hostname()
	ip := net.ParseIP(hostname)
	if ip != nil {
		if IsPrivateIP(ip) {
			return true
		}
	}

	if hostname == "localhost" || strings.HasSuffix(hostname, ".internal") || strings.HasSuffix(hostname, ".localhost") {
		return true
	}

	return false
}

func (cmd *InstallCmd) installRemote(kubeClient kubernetes.Interface, kubeContext string, host string) error {
	// first create an ingress controller
	const (
		YesOption = "Yes"
		NoOption  = "No, I already have one"
	)

	answer, err := cmd.Log.Question(&survey.QuestionOptions{
		Question:     "Should an ingress controller be installed",
		DefaultValue: YesOption,
		Options: []string{
			YesOption,
			NoOption,
		},
	})
	if err != nil {
		return err
	}
	if answer == YesOption {
		args := []string{
			"install",
			"ingress-nginx",
			"ingress-nginx",
			"--repo",
			"https://kubernetes.github.io/ingress-nginx",
			"--kube-context",
			kubeContext,
			"--namespace",
			"ingress-nginx",
			"--create-namespace",
			"--set-string",
			"controller.config.hsts=false",
			"--wait",
		}
		cmd.Log.WriteString("\n")
		cmd.Log.Infof("Executing command: helm %s", strings.Join(args, " "))
		cmd.Log.StartWait("Waiting for ingress controller deployment, this can take some time...")
		output, err := exec.Command("helm", args...).CombinedOutput()
		cmd.Log.StopWait()
		if err != nil {
			return fmt.Errorf("Error during helm command: %s (%v)", string(output), err)
		}

		cmd.Log.Done("Successfully installed ingress-nginx to your kubernetes cluster!")
	}

	password, err := cmd.getDefaultPassword(kubeClient)
	if err != nil {
		return err
	}

	// now we install loft
	args := []string{
		"install",
		"loft",
		"loft",
		"--repo",
		"https://charts.devspace.sh/",
		"--kube-context",
		kubeContext,
		"--namespace",
		cmd.Namespace,
		"--set",
		"certIssuer.create=false",
		"--set",
		"ingress.host=" + host,
		"--set",
		"cluster.connect.local=true",
		"--set",
		"admin.password=" + password,
		"--wait",
	}

	cmd.Log.WriteString("\n")
	cmd.Log.Infof("Executing command: helm %s", strings.Join(args, " "))
	cmd.Log.StartWait("Waiting for loft deployment, this can take some time...")
	output, err := exec.Command("helm", args...).CombinedOutput()
	cmd.Log.StopWait()
	if err != nil {
		return fmt.Errorf("Error during helm command: %s (%v)", string(output), err)
	}

	cmd.Log.Done("Successfully deployed loft to your kubernetes cluster!")
	cmd.Log.WriteString("\n")
	cmd.Log.StartWait("Waiting until loft pod has been started...")
	defer cmd.Log.StopWait()
	err = cmd.waitForReadyLoftPod(kubeClient)
	if err != nil {
		return err
	}
	cmd.Log.StopWait()
	cmd.Log.Done("Loft pod has successfully started")

	return cmd.successRemote(host, password)
}

func (cmd *InstallCmd) installLocal(kubeClient kubernetes.Interface, kubeContext string) error {
	cmd.Log.WriteString("\n")
	cmd.Log.Info("This will install loft without an externally reachable URL and instead use port-forwarding to connect to loft")
	cmd.Log.WriteString("\n")

	password, err := cmd.getDefaultPassword(kubeClient)
	if err != nil {
		return err
	}

	args := []string{
		"install",
		"loft",
		"loft",
		"--repo",
		"https://charts.devspace.sh/",
		"--kube-context",
		kubeContext,
		"--namespace",
		cmd.Namespace,
		"--set",
		"certIssuer.create=false",
		"--set",
		"ingress.enabled=false",
		"--set",
		"cluster.connect.local=true",
		"--set",
		"admin.password=" + password,
		"--set",
		"env.PROXY_TLS_SELF_SIGNED=true",
		"--set",
		"livenessProbe.enabled=false",
		"--set",
		"readinessProbe.enabled=false",
		// "--set",
		// "useSelfSignedCertificate=true",
		"--wait",
	}

	cmd.Log.Infof("Executing command: helm %s", strings.Join(args, " "))
	cmd.Log.StartWait("Waiting for loft deployment, this can take some time...")
	output, err := exec.Command("helm", args...).CombinedOutput()
	cmd.Log.StopWait()
	if err != nil {
		return fmt.Errorf("Error during helm command: %s (%v)", string(output), err)
	}

	cmd.Log.WriteString("\n")
	cmd.Log.Done("Successfully deployed loft to your kubernetes cluster!")
	cmd.Log.StartWait("Waiting until loft pod has been started...")
	defer cmd.Log.StopWait()
	err = cmd.waitForReadyLoftPod(kubeClient)
	if err != nil {
		return err
	}
	cmd.Log.StopWait()

	err = cmd.startPortforwarding(kubeContext)
	if err != nil {
		return err
	}

	cmd.successLocal(password)
	return nil
}

func (cmd *InstallCmd) successRemote(host string, password string) error {
	// wait until loft is reachable at the given url
	client := &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{
				InsecureSkipVerify: true,
			},
		},
	}
	resp, err := client.Get("https://" + host + "/version")
	if err == nil && resp.StatusCode == http.StatusOK {
		cmd.successMessageRemote(host, password)
		return nil
	}

	cmd.Log.WriteString(`

#########################################################################################################

Create a DNS record that point to the domain ` + host + `
from the IP address (create DNS A record) or hostname (create DNS CNAME record) of your load balancer.

To get the IP address or hostname of the load balancer for your ingress controller, run the following 
command and look for the EXTERNAL-IP:

> kubectl get services -n ingress-nginx
                                                     |---------------|
NAME                       TYPE           CLUSTER-IP | EXTERNAL-IP   |  PORT(S)                      AGE
ingress-nginx-controller   LoadBalancer   10.0.0.244 | 34.70.140.240 |  80:30984/TCP,443:31758/TCP   19m
                                                     |---------------|

The command will wait until loft is reachable under the host. You can also come back to this message 
via 'loft install'

#########################################################################################################

`)

	cmd.Log.StartWait("Waiting until loft is reachable at https://" + host)
	err = wait.PollImmediate(time.Second*5, time.Hour*24, func() (bool, error) {
		resp, err := client.Get("https://" + host + "/version")
		if err != nil {
			return false, nil
		}

		return resp.StatusCode == http.StatusOK, nil
	})
	cmd.Log.StopWait()
	if err != nil {
		return err
	}

	cmd.Log.Done("loft is reachable at https://" + host)
	cmd.successMessageRemote(host, password)
	return nil
}

func (cmd *InstallCmd) successMessageRemote(host, password string) {
	url := "https://" + host
	cmd.Log.WriteString(`

#######################################################################################

         Loft was successfully installed under ` + url + `

                   <<< Username: admin                                >>>
                   <<< Password: ` + password + ` >>>

- Login via UI (Accept untrusted certificates): ` + url + ` 
- Login via CLI: 'loft login ` + url + ` --insecure'
- Configure LetsEncrypt: https://loft.sh/docs/administration/ssl

                               Thanks for using loft!

#######################################################################################
`)
}

func (cmd *InstallCmd) successLocal(password string) {
	url := "https://localhost:" + cmd.LocalPort
	cmd.Log.WriteString(`

#######################################################################################

         Loft was successfully installed and port-forwarding was established.

 >>> If you stop this command, run 'loft login' again to restart port-forwarding <<<

                   <<< Username: admin                                >>>
                   <<< Password: ` + password + ` >>>

- Login via UI (Accept untrusted certificates): ` + url + ` 
- Login via CLI: 'loft login ` + url + ` --insecure'

                               Thanks for using loft!

#######################################################################################
`)

	blockChan := make(chan bool)
	<-blockChan
}

func (cmd *InstallCmd) getDefaultPassword(kubeClient kubernetes.Interface) (string, error) {
	if cmd.Password != "" {
		return cmd.Password, nil
	}

	loftNamespace, err := kubeClient.CoreV1().Namespaces().Get(context.TODO(), cmd.Namespace, metav1.GetOptions{})
	if err != nil {
		if kerrors.IsNotFound(err) {
			loftNamespace, err := kubeClient.CoreV1().Namespaces().Create(context.TODO(), &corev1.Namespace{
				ObjectMeta: metav1.ObjectMeta{
					Name: cmd.Namespace,
				},
			}, metav1.CreateOptions{})
			if err != nil {
				return "", err
			}

			return string(loftNamespace.UID), nil
		}

		return "", err
	}

	return string(loftNamespace.UID), nil
}

func (cmd *InstallCmd) startPortforwarding(kubeContext string) error {
	cmd.Log.WriteString("\n")
	cmd.Log.Info("Loft will now start port-forwarding to the loft pod")
	args := []string{
		"port-forward",
		"deploy/loft",
		"--context",
		kubeContext,
		"--namespace",
		cmd.Namespace,
		cmd.LocalPort + ":8080",
	}
	cmd.Log.Info("Starting command: kubectl %s", strings.Join(args, " "))

	c := exec.Command("kubectl", args...)
	// c.Stderr = os.Stderr
	// c.Stdout = os.Stdout

	err := c.Start()
	if err != nil {
		return fmt.Errorf("Error starting kubectl command: %v", err)
	}

	// wait until loft is reachable at the given url
	client := &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{
				InsecureSkipVerify: true,
			},
		},
	}

	cmd.Log.Infof("Waiting until loft is reachable at https://localhost:%s", cmd.LocalPort)
	return wait.PollImmediate(time.Second, time.Minute*10, func() (bool, error) {
		resp, err := client.Get("https://localhost:" + cmd.LocalPort + "/version")
		if err != nil {
			return false, nil
		}

		return resp.StatusCode == http.StatusOK, nil
	})
}

func (cmd *InstallCmd) getHost(kubeClient kubernetes.Interface) (string, error) {
	ingress, err := kubeClient.NetworkingV1beta1().Ingresses(cmd.Namespace).Get(context.TODO(), "loft-ingress", metav1.GetOptions{})
	if err != nil {
		return "", err
	}

	// find host
	for _, rule := range ingress.Spec.Rules {
		return rule.Host, nil
		break
	}
	return "", fmt.Errorf("couldn't find any host in loft ingress '%s/loft-ingress', please make sure you have not changed any deployed resources")
}

func (cmd *InstallCmd) waitForReadyLoftPod(kubeClient kubernetes.Interface) error {
	// wait until we have a running loft pod
	err := wait.PollImmediate(time.Second*3, time.Minute*10, func() (bool, error) {
		pods, err := kubeClient.CoreV1().Pods(cmd.Namespace).List(context.TODO(), metav1.ListOptions{
			LabelSelector: "app=loft",
		})
		if err != nil {
			cmd.Log.Warnf("Error trying to retrieve loft pod: %v", err)
			return false, nil
		} else if len(pods.Items) == 0 {
			return false, nil
		}

		loftPod := &pods.Items[0]
		for _, containerStatus := range loftPod.Status.ContainerStatuses {
			if containerStatus.State.Running != nil && containerStatus.Ready {
				continue
			} else if containerStatus.State.Terminated != nil && containerStatus.State.Terminated.ExitCode != 0 {
				cmd.Log.Warnf("There seems to be an issue with loft starting up: %s (%s). Please reach out to our support at https://loft.sh/", containerStatus.State.Terminated.Message, containerStatus.State.Terminated.Reason)
				continue
			}

			return false, nil
		}

		return true, nil
	})
	return err
}
